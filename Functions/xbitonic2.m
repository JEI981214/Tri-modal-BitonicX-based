function [X] = xbitonic2(A, varargin)
%XBITONIC2 flexible threshold-based bitonic filter for images.
%   X = XBITONIC2(A) filters A with a set of locally-adaptive masks
%   using an automatically calculated threshold and filter extent.
%
%   It is usually better to call this function via MXBITONIC2, which wraps
%   multiple layer operation around it.
%
%   The input A can be a grey 2D image, or a three colour (eg. RGB) image,
%   or a 4 channel planar CFA image, such as would be generated by using
%   rawread followed by raw2planar.
%
%   The class of A can be either double, int32 or uint8. Processing is
%   considerably faster when using int32 or uint8, which is the default for
%   image data. The presumed data range is 0 to 1 for double, 0 to 255 for
%   uint8 and 0 to 255*3 for int32. However, this only matters for 3
%   channel colour images and if the noise level (below) is set to
%   'sensor'.
%
%   X = XBITONIC2(A, noise, ...) should be used to set the noise type to
%   'additive' (if the noise has been added after the image was created),
%   or 'sensor' (if the image only contains real sensor noise). This is an
%   optional argument, but must always be the second argument if it exists,
%   and potentially makes a big difference to the results. The default is
%   'additive'.
%
%   X = XBITONIC2(A, t) uses a threshold t, representing the range of noise
%   in the data. This should normally be set to four times the standard
%   deviation of the noise. If t < 0 then it will be set automatically. It
%   is better to set this if it is known.
%
%   X = XBITONIC2(A, t, f) also uses a filter and mask size of l x l, where
%   l = 2 * f + 1. f is typically in the range 4 to 12, depending on the 
%   amount of noise in the image. If f < 0 then it will be set
%   automatically.
%
%   X = XBITONIC2(A, t, f, centile) uses centile as the minimum centile
%   for the morphological operations. The default (which is nearly always
%   the best choice) is 8.
%
%   Example:
%     A = imread('demo_data.png');
%     image(A)
%     B = xbitonic2(A);
%     image(B);
%
%   See also XRANKOPEN2, ANISOTROPIC2, MXBITONIC2

%   Author: Graham M. Treece, University of Cambridge, UK, Sept 2021.


% check for appropriate inputs
narginchk(1, 6);
v = 1;
noise = 'additive';
if (nargin>v)
  if ischar(varargin{v})
    noise = varargin{v};
    if (~strcmp(noise, 'sensor') && ~strcmp(noise, 'additive'))
      error("Noise must be either 'sensor' or 'additive'.");
    end
    v = v + 1;
  end
end
if (nargin>v)
  t = varargin{v};
  v = v + 1;
else
  % need to automate noise threshold from A
  t = -1;
end
if (nargin>v)
  f = varargin{v};
  v = v + 1;
else
  % need to automate filter length from t
  f = -1;
end
if (nargin>v)
  centile = varargin{v};
  v = v + 1;
else
  % always defaults to 8
  centile = 8;
end
if (nargin>v)
  mlevel = varargin{v};
else
  % always defaults to 0
  mlevel = 0;
end

% also check for appropriate outputs
nargoutchk(1, 1);

% check for compiled mex files
if (exist('xrankopen2','file')~=3)
  error('Type "mex xrankopen2.cpp" to compile this function.');
end
if (exist('anisotropic2_mex','file')~=3)
  error('Type "mex anisotropic2_mex.cpp" to compile this function.');
end

% check size and set filter lengths and whether to do corner detection
[m n c] = size(A);
if strcmp(class(A), 'uint8')
  minval = 0;
  maxval = 255;
  maxv = 255.0;
elseif strcmp(class(A), 'double')
  minval = 0.0;
  maxval = 1.0;
  maxv = 1.0;
else
  [minval, maxval] = bounds(A(:));
  if (c == 4)
    maxv = 4096.0; % this will not actually be used
  else
    maxv = 255.0*3.0;
  end
end
if (t<0) || (f<0)
  if (t<0)
    
    % Get std of noise from image and convert to threshold
    if strcmp(noise, 'sensor')
      if (c == 4)
        t = estimate_image_noise(A);
        t = 5.5 * t;
      else
        t = estimate_image_noise(A, 2);
        t = 5.5 * t;
      end
    else
      t = estimate_image_noise(A);
      t = 4.0 * t;
    end
    
    % reduce this for low noise scenarios
    t = t * (1.0 - 0.75 * exp( - (t*12)/double(maxval-minval) ));
    
  end
  if (f<0)
    if strcmp(noise, 'sensor')
      if (c == 4)
        f = round(2.5 + 2*log2(((t*4/5.5)/double(maxval-minval))/0.071));
      else
        f = round(2.5 + 2*log2(((t*4/5.5)/double(maxval-minval))/0.05));
      end
    else
      f = round(2.5 + 2*log2((t/double(maxval-minval))/0.02));
    end
    if (f>15)
      f = 15;
    elseif (f<3)
      f = 3;
    end
  end
  
  % Ensure user can see these estimates
  fprintf(1, "Using threshold %.3f and filter length %i.\n", t, f);
end
gf = f * 1.2;
af = 0.6;

% corner detection only worthwhile if not too much noise
if (t < 0.45*double(maxval-minval))
  do_corner = true;
else
  do_corner = false;
end

% if A is uint8, use int32
cl = class(A);
if strcmp(cl, 'uint8')
  % scale by a factor of 3 to allow more precision
  scale = 3.0;
  A = int32(A)*scale;
  t = t*scale;
else
  scale = 1.0;
end

% anisotropic on grey level input
if (c == 1)
  M = A;
  if do_corner
    [Anis, Dir, Co] = structensor2(M, gf);
    Msm = anisotropic2(double(M), gf, af, 3.0*t, Anis, Dir, Co);
  else
    [Anis, Dir] = structensor2(M, gf);
    Msm = anisotropic2(double(M), gf, af, 3.0*t, Anis, Dir);
  end
  if ~strcmp(cl, 'double')
    Msm = int32(Msm);
  end
else
  M = mean(A,3);
  if do_corner
    [Anis, Dir, Co] = structensor2(M, gf);
    Msm = anisotropic2(double(M), gf, af, sqrt(3.0)*t, Anis, Dir, Co);
  else
    [Anis, Dir] = structensor2(M, gf);
    Msm = anisotropic2(double(M), gf, af, sqrt(3.0)*t, Anis, Dir);
  end
  if ~strcmp(cl, 'double')
    M = int32(M);
    Msm = int32(Msm);
  end
end

% initial ranking
[Aopen, Aclose] = xrankopen2(A, t, f, Msm, M, centile, mlevel);

% possibly adjust for sensor noise, or just convert to double
if ((c==3) && strcmp(noise, 'sensor'))
  A = srgb_to_linear_gamma(double(A)/(scale*maxv))*maxv*scale;
  Aopen = srgb_to_linear_gamma(double(Aopen)/(scale*maxv))*maxv*scale;
  Aclose = srgb_to_linear_gamma(double(Aclose)/(scale*maxv))*maxv*scale;
  t = 0.0; % disable thresholding in remainder of process
else
  A = double(A);
  Aopen = double(Aopen);
  Aclose = double(Aclose);
end

% Smooth errors for each channel separately
Eopen = zeros(size(A));
Eclose = zeros(size(A));
if (c == 1)
  if do_corner
    Eopen = anisotropic2(A - Aopen, gf, af, 1.4*t, Anis, Dir, Co);
    Eclose = anisotropic2(Aclose - A, gf, af, 1.4*t, Anis, Dir, Co);
  else
    Eopen = anisotropic2(A - Aopen, gf, af, 1.4*t, Anis, Dir);
    Eclose = anisotropic2(Aclose - A, gf, af, 1.4*t, Anis, Dir);
  end
else
  for k=1:size(A,3)
    if do_corner
      Eopen(:,:,k) = anisotropic2(A(:,:,k) - Aopen(:,:,k), gf, af, 1.4*t, Anis, Dir, Co);
      Eclose(:,:,k) = anisotropic2(Aclose(:,:,k) - A(:,:,k), gf, af, 1.4*t, Anis, Dir, Co);
    else
      Eopen(:,:,k) = anisotropic2(A(:,:,k) - Aopen(:,:,k), gf, af, 1.4*t, Anis, Dir);
      Eclose(:,:,k) = anisotropic2(Aclose(:,:,k) - A(:,:,k), gf, af, 1.4*t, Anis, Dir);
    end
  end
end

% Remove offsets from Aopen and Aclose
Aclose = Aclose - Eclose;
Aopen = Aopen + Eopen;
  
% Increase weighting factor
Eopen = abs(Eopen.^3);
Eclose = abs(Eclose.^3);
  
% find sum of weighting values (output of gaussian filters), remove zeros
Esum = Eopen+Eclose;
n = (Esum==0);
Eopen(n) = 0.5;
Eclose(n) = 0.5;
Esum(n) = 1.0;
  
% output is weighted sum of ordinal operations
X = (Eopen.*Aclose + Eclose.*Aopen)./Esum;

% possibly adjust for sensor noise
if ((c==3) && strcmp(noise, 'sensor'))
  X = linear_gamma_to_srgb(X/(scale*maxv))*maxv;
else
  X = X / scale;
end

if strcmp(cl, 'uint8')
  X = uint8(X);
elseif strcmp(cl, 'int32')
  X = int32(X);
end